# Linear Regression Using Bayesian Inference {#sec-linear-reg-bayes}

```{r}
#| echo: false
options(buildtools.check = function(action) TRUE)
```

In the previous chapter, we introduced the fundamental philosophy of Bayesian inference. We learned to view population parameters not as fixed, unknown constants to be estimated, but as random variables described by probability distributions. We explored how to combine prior beliefs with observed data to form posterior beliefs, and we applied this logic to basic hypothesis testing.

In this chapter, we will revisit Linear Regression, but this time through the lens of Bayesian inference. We will learn how to specify, fit, and interpret Bayesian Linear Regression models, as well as perform certain diagnostics specific to Bayesian estimation methods.  As with classical linear regression, much of what we learn in this chapter will generalize to other types of Bayesian regression models, such as Bayesian logistic regression and Bayesian Poisson regression, which we will cover in the next chapter.  

While classical Ordinary Least Squares (OLS) regression---which we covered extensively in @sec-linear-reg-ols---remains a powerful tool, Bayesian Linear Regression offers distinct advantages which are precisely the advantages offered by Bayesian inference more generally. It allows us to incorporate prior knowledge, it functions well even with smaller sample sizes, and perhaps most importantly, it provides a rich, probabilistic interpretation of our model coefficients and predictions. On the other hand, Bayesian regression models can be computationally intensive and require careful consideration of priors and convergence diagnostics.

To implement Bayesian regression models in R, we will use the `brms` package. This package serves as an accessible interface to `stan`, a state-of-the-art platform for statistical modeling and high-performance statistical computation based on Markov Chain Monte Carlo (MCMC) methods. The beauty of `brms` is that it allows us to fit Bayesian models using syntax that is almost identical to the classic `lm()` and `glm()` functions we already know.

## Applying Bayes' Theorem to Linear Regression

Recall from @sec-linear-reg-ols that the purpose of linear regression is to explain or predict an outcome measured on a continuous scale using one or more input variables.   The assumption is that each observation $y_i$ of the outcome variable $y$ is generated by a linear combination of the corresponding observations of the input variables $x_{i1}, x_{i2}, \dots, x_{ik}$ plus some normally distributed error term:

$$y_i = \beta_0 + \beta_1 x_{i1} + \dots + \beta_k x_{ik} + \epsilon_i$$

where 

* $\beta_0$ is the intercept coefficient
* $\beta_1, \beta_2, \dots, \beta_k$ are the 'slope' coefficients for each input variable
* $\epsilon_i$ is the error term for observation $i$, assumed to be normally distributed with mean 0 and variance $\sigma^2$, that is $\epsilon_i \sim N(0, \sigma^2)$.

In the classical (frequentist) framework, our goal is to find the point estimates for the $\beta$ coefficients that minimize the sum of squared errors. We assume there is one true line that best fits the data, and we calculate standard errors to construct confidence intervals around that line.

In the Bayesian framework, we conceptualize the problem differently. We assume that each observation $y_i$ of the outcome variable comes from a normal distribution characterized by a mean $\mu_i$ and a standard deviation $\sigma$:

$$y_i \sim N(\mu_i, \sigma)$$

where the mean $\mu_i$ is still modeled as a linear combination of the input variable observations:

$$\mu_i = \beta_0 + \beta_1 x_{i1} + \dots + \beta_k x_{ik}$$

The crucial difference is that $\beta_0, \beta_1, \dots, \beta_k$ and $\sigma$ are not fixed values we are trying to hunt down. They are random variables with their own distributions. Our goal is to learn the Posterior distribution of each these parameters given our data.  If we use $\beta$ to represent the vector of all regression coefficients, and noting that our data consists of the outcome variable vector $y$ and the matrix of input variables $X$, what we are looking for is the posterior distribution $P(\beta, \sigma \mid y, X)$.  In this context, Bayes' Theorem can be restated as:

$$
P(\beta, \sigma \mid y, X) \propto P(y \mid X, \beta, \sigma)P(\beta, \sigma)
$$

This means that the output of a Bayesian regression is not a single line or hyperplane that best fits the data, but a probability distribution of *all possible lines or hyperplanes* that are consistent with our data and our priors.  We are simulating posteriors for multiple parameters, and as you can imagine, this will need some computational horsepower.

Calculating the posterior distribution for complex models with multiple parameters is mathematically impossible to do using simple algebra. To solve this, we will need to employ Markov Chain Monte Carlo (MCMC) simulation.  MCMC is a class of algorithms used to sample from complex probability distributions. MCMC algorithms work by constructing Markov chains (sequences of random steps whose long-run behavior mimics the target distribution). A Markov chain starts from an initial point in the parameter space, and then proposes moves to new points, accepting or rejecting them according to rules that ensure the chain will eventually sample in proportion to the desired distribution. Over many iterations, the collected samples approximate the underlying distribution, enabling estimation of quantities like means, variances, and credible intervals even in high-dimensional problems.

## Running a Bayesian linear regression model

We will use a random subset of the `ugtests` dataset from @sec-linear-reg-ols, which contains information about undergraduate students' scores over four years of their program. Our goal is to predict the `Final` year score based on the `Yr1`,`Yr2` and `Yr3` scores using Bayesian Linear Regression.  Initially, we will assume that this subset is all the data we have available for our model. 


```{r}
# Load necessary packages
library(brms)  
library(bayesplot)
library(ggplot2)  

# if needed, download ugtests data
url <- "http://peopleanalytics-regression-book.org/data/ugtests.csv"
ugtests <- read.csv(url)

# take a random sample of 100 rows
set.seed(123)
sample_1 <- sample(nrow(ugtests), 100)
ugtests_bayes <- ugtests[sample_1, ]
```

### Specifying the Model

In `brms`, we use `brm()` with the `family = gaussian()` argument to fit a Bayesian linear regression model. The syntax is very similar to `lm()` and `glm()` for our previous chapters, but with a few extra arguments regarding the Bayesian specifics.  If `brm()` is not given any priors, it will use a set of default priors which assume we have no ingoing beliefs about any of our parameters.  

Let's first fit a multiple linear regression model, accepting the default priors. You may find that the MCMC simulations in `brms` models take some time to run, depending on the processing power and memory you have available as well as the choices you make about the scale of your simulation.  


```{r}
# Fit a weakly informed Bayesian Linear Regression Model
set.seed(123)
noninf_model <- brm(
  formula = Final ~ Yr1 + Yr2 + Yr3,
  data = ugtests_bayes,
  family = gaussian(), # Indicates linear regression (gaussian/normal distribution)
  chains = 4,          # Number of independent MCMC chains 
  iter = 10000,         # Number of steps in each MCMC chain 
  refresh = 0,         # Suppress progress output (optional)
  silent = 1,        # Reduce console output (optional)
  save_pars = save_pars('all') # save all parameters for later use (optional)
)
```

Let's review the various arguments we passed to `brm()`:

*   `formula` & `data`: This is the same as we use in `lm()`.
*   `family = gaussian()`: Tells tells `stan` that we are doing standard linear regression (assuming errors are normally distributed).
*   `chains`: We run 4 independent MCMC simulations to ensure they all converge to the same answer.
*   `iter`: How many steps the simulation takes. The first 30-50% are usually discarded as "warm-up" iterations to learn the shape of the posterior, and the second half are kept for analysis.  The more complex the model, the more iterations are usually needed to ensure convergence.
*   `refresh`: Controls how often the MCMC simulation progress is printed to the console. Setting to 0 suppresses output.
*   `silent`: Reduces status output so that only the most critical messages appear.
*   `save_pars`: Saves all parameters from the model locally for later use.

If we want to see the priors used by a `brms` model, we just need to use the `get_prior()` function:

```{r}
# Check the priors used in the model
get_prior(noninf_model)
```
This output means that the following priors have been used in our initial model:

*  **Intercept Coefficient**: A Student-$t$ distribution with 3 degrees of freedom, and with the mean and scale automatically determined based on the data.
*  **'Slope' Coefficients (`b`)**: A Uniform distribution across all real numbers, each with equal probability.  This is effectively the "flat" prior, indicating no ingoing knowledge about the coefficients.
*  **Residual standard deviation (`sigma`)**: A Student-$t$ distribution with 3 degrees of freedom, and with the scale automatically determined based on the data.  This is actually a half-distribution as `sigma` must be positive.

### Interpreting the Results

Once the model is fit, we can examine the results. Unlike `lm()`, which gives us t-statistics and p-values, `brm()` gives us summaries of the posterior distribution.

```{r}
# View summary of the model
summary(noninf_model)
```

We can understand the basic summary output of estimates in a very similar way to OLS regression:

1.  The `Estimate` column provides the medians of the posterior distributions for each parameter.  In this case: 
    *   `Intercept`: This is the posterior mean of the final year score assuming there was a score of zero in all of the previous years.
    *   `Yr1`: This is the posterior mean change in Final year score associated with a one point increase in Year 1 score, assuming no change in the other input variables.
    *   `Yr2`: This is the posterior mean change in Final year score associated with a one point increase in Year 2 score, assuming no change in the other input variables.
    *  `Yr3`: This is the posterior mean change in Final year score associated with a one point increase in Year 3 score, assuming no change in the other input variables.
    *  `sigma`: This is the posterior mean of the standard deviation of the residuals (the noise in the data not explained by the model).

2.  The `Est.Error` column is the standard deviation of the posterior distributions. It represents the uncertainty of our estimates. 

3.  The `l-95% CI` and `u-95% CI` columns provide lower and upper bounds of the 95% credible intervals for the parameters. To dislay a different credible interval you can use the `prob` argument in the summary command (e.g., `prob = 0.8` for an 80% credible interval). 

4.  The remaining columns provide information about the MCMC simulation.  In particular:
    *   `Rhat`: The potential scale reduction factor. Values close to 1 indicate good convergence of the chains. Values significantly greater than 1 suggest that the chains have not converged well.
    *   `Bulk_ESS` and `Tail_ESS`: The effective sample sizes. These indicate how many independent samples the MCMC simulation effectively produced in the 'bulk' (5-95% quantiles) of the distribution and in the tails (outside the 5-95% quantiles) . Higher values are better, with at least 1000 considered minimally sufficient.  This ensures that the are sufficient samples representing random variables that are independent and identically distributed (i.i.d.).


### Specifying informative priors

Although the default priors are generally fit for purpose in the `brm()` function, there are times when we may have strong prior knowledge that may cause us to adjust one or more of our priors. Imagine you are give the following information by expert faculty

1.  No scores are known to be negatively associated with Final year scores.   
2.  Year 1 scores are typically very weakly associated with Final year scores or sometimes not at all associated.
3.  Year 2 and Year 3 scores are typically progressively more positively associated with Final year scores. 

This suggests that we could suggest a more informative prior for our Year 1 coefficient.  We can encode new beliefs into our model by specifying informative priors.  We can do this using the `prior()` function in `brms`.  Let's specify a normal prior for the `Yr1` coefficient centered around 0 to reflect our belief that it has a weak or null effect on Final year scores.  Let's also specify a very narrow standard deviation to indicate a strong belief.

To assign a prior to a specific parameter in the `prior()` function, we use the `class` and `coef` arguments.  The `class` argument indicates the type of parameter (e.g., `b` for slope coefficients, `Intercept` for the intercept, `sigma` for the residual standard deviation), while the `coef` argument specifies which `b` variable the prior applies to.  Any paraemeters not explicitly assigned a prior will use the default priors.


```{r}
# Define informative priors on the Yr1 coefficient
priors <- c(
  prior(normal(0, 0.05), class = b, coef = Yr1)
)

# run an informed model with this prior
set.seed(123)
inf_model <- brm(
  formula = Final ~ Yr1 + Yr2 + Yr3,
  data = ugtests_bayes,
  family = gaussian(),
  prior = priors,
  chains = 4,
  iter = 10000,
  refresh = 0,
  silent = 1,
  save_pars = save_pars('all')
)
```

Let's view our informed model summary:

```{r}
# View summary of the informed prior model
summary(inf_model)
```

We now see that our posterior estimates have shifted based on our prior beliefs. The `Yr1` coefficient is now closer to zero, better reflecting our belief that it has a weak to null effect on the Final year score.  Note that, although this new model has coefficients that are more aligned with our prior beliefs, this does not necessarily mean it will perform better than our uninformed model.

## Examining posteriors

### Visualizing Posterior Parameter Distributions

Visualization is a particularly important communication tool in Bayesian statistics, because we are communicating uncertainty about our parameters. We can plot the distributions of plausible values for our informed model coefficients using the `mcmc_areas()` function from the `bayesplot` package.

::: {#fig-bayes-areas}
```{r}
# Plot posterior distributions for coefficients
library(bayesplot)

mcmc_areas(
  inf_model, 
  pars = c("b_Yr1", "b_Yr2", "b_Yr3"),
  prob = 0.66, # 66% Credible Interval (shaded dark)
  prob_outer = 0.95 # 95% Credible Interval (limits)
) +
  theme_minimal()
```

Posterior distributions for the coefficients of our informed Bayesian linear regression model.
:::

In @fig-bayes-areas, the dark line at the peak of the density curve represents the most likely value for the coefficient. The width of the shaded area represents a 0.66 credible interval for the parameter, while the entire range plotted represents the 95% credible interval.

We can also look at the intervals explicitly using `mcmc_intervals`:

::: {#fig-bayes-intervals}
```{r}
mcmc_intervals(
  inf_model, 
  pars = c("b_Yr1", "b_Yr2", "b_Yr3"),
  prob = 0.66, 
  prob_outer = 0.95
) +
  theme_minimal()
```

66% (dark lines) and 95% (light lines) Credible intervals for the coefficients of our informed Bayesian linear regression model.
:::

Both of these visualizations are helpful in verifying our interpretations of the coefficients. For example, we can see that the 95% credible interval for the `b_Yr1` coefficient includes zero, suggesting that there is a reasonable probability that Year 1 scores have little to no effect on `Final` scores, consistent with our prior beliefs.

### Posterior Predictive Distribution

Bayesian regression allows us to more precisely quantify our uncertainty when predicting outcomes for new data. In OLS regression, we typically get a single predicted value (point prediction) and perhaps a prediction interval. in Bayesian analysis, we generate a full Posterior Predictive Distribution (PPD). This distribution captures both our uncertainty about the model coefficients and the inherent variability in the data (the error term $\sigma$). 

For every simulated set of coefficients in our posterior, the model generates a prediction. This results in a distribution of predicted Final year scores.  Let's predict the Final year score for an improving student.

```{r}
# Define new data
new_student <- data.frame(Yr1 = 43, Yr2 = 111, Yr3 = 143)

# Generate posterior predictive distribution
post_pred <- posterior_predict(inf_model, newdata = new_student)

# Convert to data frame for plotting
pred_values <- data.frame(Final = as.vector(post_pred))
```

We can now plot exactly what we expect this student's Final year score to look like, including our uncertainty about the model parameters *and* the natural noise ($\sigma$) in the data.

::: {#fig-post-predict}
```{r}
library(ggdist)

# Plot the predictive distribution in a halfeye plot
ggplot(pred_values, aes(x = Final)) +
  stat_halfeye(
    .width = c(0.66, 0.95),
    fill = "lightblue",
    color = "blue"
  ) +
  labs(y = "Probability") +
  theme_minimal()
```

Distribution of predicted Final year score for a new student
:::

We can compute the 95% Prediction Interval directly from these samples:

```{r}
quantile(pred_values$Final, probs = c(0.025, 0.975)) |> 
  round()
```

This interval tells us that, given our model and data, there is a 95% probability that this specific student's Final score will fall within this range.

## Model Comparisons

Let's create a simple uninformed Bayesian linear regression model using just `Yr2` as an input variable, so we can compare it to our full uninformed and informed models.

```{r}
# Fit a simpler Bayesian Linear Regression Model
set.seed(123)
simple_model <- brm(
  formula = Final ~ Yr2,
  data = ugtests_bayes,
  family = gaussian(),
  chains = 4,
  iter = 10000,
  refresh = 0,
  silent = 1,
  save_pars = save_pars('all')
)
```

There are a number of ways we can compare the fit of Bayesian linear models. Some common ways involve computing R-squareds, determining predictive accuracy, or performing hypothesis tests on model fit.

### Bayesian $R^2$

We can calculate a Bayesian version of $R^2$. Unlike the single number in OLS regression, Bayesian $R^2$ is a distribution (because the coefficients are distributions). `brms` provides a convenient function `bayes_R2()` to compute this.  Let's use it to compare the fit of our models.

```{r}
# Calculate full posterior R-squareds
r2_noninf_full <- bayes_R2(noninf_model, summary = FALSE)
r2_inf_full <- bayes_R2(inf_model, summary = FALSE)
r2_simple <- bayes_R2(simple_model, summary = FALSE)

# create data frame for visualization
r2_df <- data.frame(
  R2 = c(r2_noninf_full[,1], r2_inf_full[,1], r2_simple[,1]),
  Model = rep(c("Uninformed Full", "Informed Full", "Simple"), each = nrow(r2_noninf_full))
)

# plot posterior r-squared for all models
ggplot(r2_df, aes(x = R2, fill = Model)) +
  stat_halfeye(
    .width = c(0.66, 0.95),
    position = position_dodge(width = 0.5),
    alpha = 0.6
  ) +
  labs(y = "Probability") +
  theme_minimal()
```
We can see that our simple model has a very poor fit compared to both full models, which seem to be very similar in fit.  

### LOO Cross-Validation

We can use Leave-One-Out Cross-Validation (LOO-CV), which estimate out-of-sample predictive accuracy, to compare the predictive accuracy of models.       

```{r}
# Compare models using LOO
loo_simple <- loo(simple_model)
loo_informed_full <- loo(inf_model)
loo_noninformed_full <- loo(noninf_model)
loo_compare(loo_simple, loo_informed_full, loo_noninformed_full)
```

The results will always rank the best performing model first, and shows the difference in expected log predictive density (ELPD) between the models.  A difference of more than 4 points is generally considered meaningful, but only if the standard error of the difference is small enough (less than half the ELPD difference itself).  In this case, we can see that our informed and uninformed models are virtually identical, while both full models are meaningfully better than the simple model.

### Hypothesis testing on model fit {#sec-bayes-model-hyp-test}

We can test the hypothesis that a model is a better fit than another using the Bayes Factor, which we covered in @sec-bayes-hyp-test.  We can use the `bayes_factor()` function to compute Bayes Factors for model hypothesis tests.  Let's test that our informed full model is a better fit than our simple model.

```{r}
# Compute Bayes Factor for model comparison
set.seed(123)
bayes_factor(inf_model, simple_model)
```
We can see that the Bayes Factor very strongly supports the informed full model over the simple model.  Bayes Factor tests can be highly unreliable unless there has been extensive MCMC simulations performed during model fitting. It is recommended that at least 40,000 iterations are performed in model fitting to allow reliable Bayes Factor estimates.  If you are unsure about the stability of your Bayes Factor estimates, you can rerun the model fitting with a higher number of iterations and see if the Bayes Factor changes significantly. 

## Variable Standardization and Coefficient Hypothesis Testing

### Dealing with variable scale issues via standardization

When our data variables are on different scales, it can complicate the interpretation of coefficients and the setting of priors.  In our data, the input variable `Yr1` is on a different scale to `Yr2` and `Yr3`, and all of them are on a different scale to our outcome variable.   This means that when we interpret our coefficients, the effect a one unit increase in `Yr1` is not comparable with that of a one unit increase in `Yr2` or `Yr3`.  This can make it difficult to set meaningful priors for our coefficients, as the scale of the coefficients will be affected by the scale of the input variables.  It can also make hypothesis testing on the coefficients more difficult, as the ROPE (Region of Practical Equivalence) may not be meaningful if the input variables are on different scales.

Explicitly standardizing the scales of our variables before modeling can have benefits in defining our priors and in running hypothesis tests.  We can standardize the scales of our variables using the `scale()` function in R.  This function takes the mean of each variable and sets it to zero, and expresses each value as a positive or negative multiple of the standard deviation from the mean.

```{r}
#  Standardize all variables
library(dplyr)

ugtests_bayes_std <- ugtests_bayes |> 
  mutate(across(everything(), scale))
```

Now we can rerun our informed model on the scaled data:

```{r}
# Fit the Bayesian Linear Regression Model on standardized data
priors_std <- c(
  prior(normal(0, 0.05), class = b, coef = Yr1)
)

set.seed(123)
inf_model_std <- brm(
  formula = Final ~ Yr1 + Yr2 + Yr3,
  data = ugtests_bayes_std,
  family = gaussian(),
  prior = priors_std,
  chains = 4,
  iter = 40000,
  refresh = 0,
  silent = 1,
  save_pars = save_pars('all')
)

summary(inf_model_std)
```

Working with the standardized model has several advantages.  First, the coefficients are now directly comparable to each other, since they are all expressed in terms of standard deviations.  Previously, the effect of a one unit increase in `Yr1` was not comparable to that of a one unit increase in `Yr2`, since they were on different scales.  Now, the effect of a one standard deviation increase in `Yr1` is directly comparable to that of a one standard deviation increase in `Yr2`.  This makes it easier to interpret the relative importance of each input variable.  However, this also means that must be careful when interpreting the coefficients in the context of the original data.  We must now refer to the effect of a change of one standard deviation rather than the effect of a change of one unit.  Furthermore, predictions from our standardized model will be generated in scaled units, so we will need to back-transform them to the original scale for interpretation.

One of the most significant benefits of standardizing our variables is that it allows us to more safely perform hypothesis tests on the coefficients of our models, using some methods which we will now explore.

### Hypothesis testing on coefficients using ROPE

With our standardized model, we can more safely use the `describe_posterior()` function from the `bayestestR` package to get a description of the posterior distributions.

```{r}
library(bayestestR)
describe_posterior(inf_model_std)
```

The ROPE (Region of Practical Equivalence) is typically determined to be between -0.1 and 0.1 standard deviations of the output variable (@kruschke).  If the input variables are on a different scale to the output variable (as they were in our earlier modeling), the ROPE may not make sense.  Because we have standardized the variables, we can be more confident that the ROPE is meaningful.  This summary suggests that `Yr2` and `Yr3` are extremely likely to be positive predictors of `Final`, while `Yr1` is not.  A more terse summary can be obtained by using the `equivalence_test()` function, which will explicitly reject coefficients that are practically different from zero:


```{r}
# test for equivalence of coefficients to zero
equivalence_test(inf_model_std)
```

### Hypothesis testing on coefficients using the `hypothesis()` function

The `hypothesis()` function can provide statistics related to a directional alternative hypothesis for each coefficient. For example, we can test if each slope coefficient is positive in our standardized model:


```{r}
# test alternative hypothesis that slope coefficients are greater than zero
set.seed(123)
hypothesis(inf_model_std, hypothesis = c("Yr1 > 0", "Yr2 > 0", "Yr3 > 0"), class = "b")
```

The evidence ratio  (`Evid.Ratio`) is the Bayes Factor in favor of the alternative hypothesis, while the posterior probability (`Post.Prob`) is the probability that the alternative hypothesis is true given the data and priors.

We see that two of our coefficients are virtually certain to be positive given our priors and data.  However, as in @sec-bayes-model-hyp-test,
the Bayes Factor will be unreliable if not enough MCMC iterations have been generated.

### Testing specific hypotheses about coefficients

We may want to test very specific hypotheses about our coefficients, and Bayesian inference gives us a great deal of flexibility to do this.  For example, if we wanted to know the probability that the Year 3 score has more than double the effect of the Year 2 score, we can do this by extracting the posterior draws^['Draws' are a common term for samples taken from the simulated posterior.] and calculating the proportion of them where this condition holds.


```{r}
# Extract posterior samples from standardized model
posterior_samples <- as_draws_df(inf_model_std)

# Calculate the probability that Yr3 > 2*Yr2
prob_Yr3_greater_Yr2 <- mean(posterior_samples$b_Yr3 > 2*posterior_samples$b_Yr2)
round(prob_Yr3_greater_Yr2, 2)
```

This allows us to say that there is a `r round(prob_Yr3_greater_Yr2*100)`% probability that the effect of `Yr3` is more than double that of `Yr2`, given our priors and data.  Note that we can only make this statement because we are working with a model fitted to standardized data.

## Bayesian updating of regression models

Recall from @sec-bayes-updating that Bayesian inference allows us to update our beliefs as new data becomes available.  In the context of a regression model, we can use the posterior distributions from an initial model as the priors for a new model fitted on additional data.  This is particularly useful in situations where data arrives sequentially or in batches.  Let's say we have a new batch of data for another 100 students.  We can fit a new model using the posterior distributions from our informed model as priors.

```{r}
# remove prior sample from ugtests
ugtests_rm <- ugtests[-sample_1, ]

# take a new samplw of 100 rows from remaining data
set.seed(123)
sample_2 <- sample(nrow(ugtests_rm), 100)
ugtests_bayes_update <- ugtests_rm[sample_2, ]
```

Now we can use the function `model_to_priors()` from the `bayestestR` package to extract the posterior distributions from our previous model and use them as priors for our new model.

```{r}
library(bayestestR)
new_priors <- model_to_priors(
  inf_model,
  dpar = "b" # indicates we want priors for the coefficients
)
```

We can view our new priors before we decide to use them:

```{r}
# View new priors extracted from previous model
new_priors
```
Now we can utilize these as priors in our new model with updated new data:

```{r}
# Fit updated model with new data and previous posteriors as priors
set.seed(123)
updated_model <- brm(
  formula = Final ~ Yr1 + Yr2 + Yr3,
  data = ugtests_bayes_update,
  family = gaussian(),
  prior = new_priors,
  chains = 4,
  iter = 10000,
  refresh = 0,
  silent = 1,
  save_pars = save_pars('all')
)
```

Now we can compare the mean estimates of our original informed model and our updated model to see how our beliefs have changed with the new data.

```{r}
# Compare mean fixed effects of original and updated models

inf_model_effects <- fixef(inf_model)[, "Estimate"]
updated_model_effects <- fixef(updated_model)[, "Estimate"]

cbind(inf_model_effects, updated_model_effects)
```
We can see that our new batch of data has updated the model towards even stronger effects for the Year 2 and Year 3 scores.

We can also compare our fits using one of our model comparison methods.  Let's use Bayesian $R^2$ to compare the original informed model and the updated model.

:::{#fig-bayes-r2-update}

```{r}
# Compare original and updated models using bayes R2
r2_updated <- bayes_R2(updated_model, summary = FALSE)

# create data frame for visualization
r2_update_df <- data.frame(
  R2 = c(r2_inf_full[,1], r2_updated[,1]),
  Model = rep(c("Informed Original", "Informed Updated"), each = nrow(r2_inf_full))
)

# plot posterior r-squared for both models
ggplot(r2_update_df, aes(x = R2, fill = Model)) +
  stat_halfeye(
    .width = c(0.66, 0.95),
    alpha = 0.6
  ) +
  labs(y = "Probability") +
  theme_minimal()
```

Bayesian R-squared distributions for the original informed model and the updated model after incorporating new data.
::: 

We can see from @fig-bayes-r2-update that the new data has improved the fit of the model, and the spikier posterior suggests a higher level of credibility around that fit.

## Model Diagnostics and Validation

Because Bayesian models rely on MCMC simulation, we must verify that the simulation worked correctly. If our MCMC chains did not behave as expected, our results will probably be invalid. There are several diagnostics we can use to assess the quality of our MCMC simulation.

### Trace Plots

Trace plots show the path of the MCMC sampling chains. We want to see "fuzzy caterpillars"-â€”-chains that mix well and oscillate around a stable mean. We do not want to see trends (going up or down) or chains that stay separate from each other.  We can use the `mcmc_trace()` function from the `bayesplot` package to visualize the trace plots for our model coefficients.

::: {#fig-trace-plot}
```{r}
# Plot trace plots for coefficients
mcmc_trace(inf_model, pars = c("b_Yr1", "b_Yr2", "b_Yr3")) +
  theme_minimal()
```

Trace plots of the MCMC simulation. The four colors represent the four independent chains. The fact that they look like random noise and overlap perfectly, giving a "hairy caterpillar" appearance, indicates good convergence.
:::

### Posterior Predictive Checks

Another critical check is to see if the model can generate data that looks like our observed data. This is called a **Posterior Predictive Check (PPC)**. If our model is good, data drawn from the model's posterior should resemble the `Final` histogram of our actual dataset.  We can use the `pp_check()` function for this.

::: {#fig-pp-check}
```{r}
# Posterior predictive check using 100 posterior draws
pp_check(inf_model, ndraws = 100) +
  theme_minimal()
```

Posterior Predictive Check. The dark line ($y$) is the distribution of our actual Final year data. The light blue lines ($y_{\mathrm{rep}}$) are 100 draws of Final year distributions from our model posterior.
:::

In @fig-pp-check, we see that the distributions drawn from the posterior simulations (light blue) overlay the actual data (dark blue) to within a reasonable range. This suggests our model structure (Linear Regression) fits the data generating process well. If, for instance, the real data had two humps (bimodal) and our simulations only had one, this would raise a concern that the model is misspecified.


### Sensitivity to priors and other considerations 

It is good practice to check how sensitive your results are to the choice of priors. You can do this by fitting the model with different priors (e.g., weakly informative vs. strongly informative) and comparing the posterior distributions of the coefficients. If the posteriors change significantly with different priors, it suggests that your data may not be strong enough to overcome the influence of the priors.  If this is the case, it would be important to acknowledge this in your analysis and consider collecting more data if possible.  

On the other hand, large samples can result in priors being 'swamped' or 'overwhelmed' by the data, leading to similar posterior distributions regardless of the priors used.  This is not necessarily a problem, but it is important to be aware of this phenomenon when interpreting your results.  In cases where priors are swamped, one of the values of Bayesian inference is negated (namely the ability to incorporate prior knowledge).  However, the other advantages of Bayesian inference (such as the rich probabilistic interpretation of coefficients and predictions) still hold.  It is the choice of the analyst to decide whether Bayesian inference is appropriate in such cases.

Many of the other model diagnostics we used in OLS regression (e.g., residual plots, tests for homoscedasticity, etc.) are still applicable in Bayesian regression.  The mean of the Posterior Predictive Distribution can be used to compute residuals, and these can be analyzed in the same way as in OLS regression to check residual distribution and homoscedasticity.  As with classical models, the `fitted()` function can be used to extract the mean fitted values from the model.

## Learning exercises

### Discussion questions

1.  What are "weakly informative priors"? Why might an analyst prefer these over "flat" (uninformative) priors or informative priors?

2.  Briefly explain the purpose of Markov Chain Monte Carlo (MCMC) simulation in Bayesian regression.

3.  How does the interpretation of a regression coefficient ($\beta$) differ between the classical regression framework and the Bayesian framework?

4.  What is a posterior predictive distribution (PPD), and how does it differ from a fitted point prediction in OLS regression?

5.  What information does the `Rhat` statistic provide about MCMC convergence? What values of `Rhat` indicate good convergence?

6.  What are three ways to compare the fit of Bayesian regression models? Briefly describe each.

7.  Explain how to interpret the results of a comparison between two models using Leave One Out Cross-Validation (LOO-CV).

8.  In a Bayes Factor hypothesis test of regression models or model coefficients, what primarily determines how reliable the Bayes Factor estimate is?

9.  Why is variable standarization helpful when defining informative priors or using a Region of Practical Equivalence (ROPE) for hypothesis testing?

10.  Describe what a "Trace Plot" and a "Posterior Predictive Check" (PPC) show, and what patterns (or lack thereof) indicate a healthy and well-specified model.

### Data exercises

Use the `sociological_data` set from the exercises in @sec-lin-reg-ols-exercises. Ensure that categorical variables are coerced to factors and missing data is removed.  Reduce the size of the dataset by taking a random sample of 100 rows.  Ensure you set a seed to ensure you can replicate your work.  

1.  Fit a Bayesian linear regression model predicting `annual_income_ppp` using all other variables in the dataset. Use `brm` with `chains = 4`, `iter = 2000`, and the default priors.

2.  Run a summary of the model. Examine the `Rhat` and `Bulk_ESS`/`Tail_ESS` columns. Did the chains converge successfully?

3.  Generate Trace Plots for the coefficients of `education_months` and `family_size`. Do they resemble "fuzzy caterpillars"?

4.  Visualize the posterior distributions of the coefficients using `mcmc_areas()`.

5.  Interpret the posterior mean and the 95% credible interval for the `education_months` coefficient. Can you state with 95% probability that education has a positive effect on income?

6.  Imagine you possess expert knowledge from a previous study suggesting that `family_size` usually has a slightly negative effect on income, and `work_distance` generally has no effect.  Construct and examine a new model using informative priors as follows:
    *   Set a normal prior for `family_size` with a location (mean) of -0.2 and a tight scale.
    *   Set a normal prior for `work_distance` with a location of 0 and a tight scale.
    *   Maintain the other priors by setting their location to 0 and their scale to 2.5.
    *   Consider how to set the priors appropriately for the categorical variables (Hint: look at the coefficient summary from your weakly informed model).

7.  Compare your "Uninformed" model (from Question 1) and your "Informed" model (from Question 8) using `bayes_R2()`. Visualise the two distributions of $R^2$. Does the incorporation of prior beliefs significantly change the explained variance?

8. Use Leave-One-Out Cross-Validation to compare the predictive performance of the two models. Which model is preferred?

9. Using your preferred model, perform a Posterior Predictive Check (`pp_check`). Does the simulated data resemble the observed distribution of `annual_income_ppp`?

10. Run your preferred model on scaled version of your new data.  Determine which coefficients are practically different from zero based on the ROPE.  

11. Using your scaled model, calculate the specific probability that the coefficient for `education_months` is larger than the coefficient for `languages`.

12. Take a further sample of 100 rows from the remaining rows of the `sociological_data` dataset.  Fit an updated model using the posterior distributions from your (undtandardized) preferred model as priors.  Compare the mean coefficient estimates of the updated model to your preferred model.  How have the coefficients changed with the new data?  

13. Create a hypothetical individual profile (a new dataframe) representing a skilled worker with high education and a large family.  Using your updated model, generate the Posterior Predictive Distribution for this individual's income. Plot the distribution.

16. Report the 90% Prediction Interval for this individual. Explain, in plain language, what this interval represents regarding the uncertainty of your prediction.

