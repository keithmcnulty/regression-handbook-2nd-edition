# Linear Regression Using Bayesian Inference {#sec-linear-reg-bayes}

In the previous chapter, we introduced the fundamental philosophy of Bayesian inference. We learned to view population parameters not as fixed, unknown constants to be estimated, but as random variables described by probability distributions. We explored how to combine prior beliefs with observed data to form posterior beliefs, and we applied this logic to basic hypothesis testing.

In this chapter, we will revisit Linear Regression, but this time through the lens of Bayesian inference. We will learn how to specify, fit, and interpret Bayesian Linear Regression models, as well as perform certain diagnostics specific to Bayesian estimation methods.  As with classical linear regression, much of what we learn in this chapter will generalize to other types of Bayesian regression models, such as Bayesian logistic regression and Bayesian Poisson regression, which we will cover in the next chapter.  

While classical Ordinary Least Squares (OLS) regression---which we covered extensively in @sec-linear-reg-ols---remains a powerful tool, Bayesian Linear Regression offers distinct advantages which are precisely the advantages offered by Bayesian inference more generally. It allows us to incorporate prior knowledge, it functions well even with smaller sample sizes, and perhaps most importantly, it provides a rich, probabilistic interpretation of our model coefficients and predictions. On the other hand, Bayesian regression models can be computationally intensive and require careful consideration of priors and convergence diagnostics.

To implement Bayesian regression models in R, we will use the `rstanarm` package. This package serves as an accessible interface to `stan`, a state-of-the-art platform for statistical modeling and high-performance statistical computation based on Markov chain Monte Carlo methods. The beauty of `rstanarm` is that it allows us to fit Bayesian models using syntax that is almost identical to the classic `lm()` and `glm()` functions we already know.

## Applying Bayes' Theorem to Linear Regression

Recall from @sec-linear-reg-ols that the purpose of linear regression is to explain or predict an outcome measured on a continuous scale using one or more input variables.   The assumption is that each observation $y_i$ of the outcome variable $y$ is generated by a linear combination of the corresponding observations of the input variables $x_{i1}, x_{i2}, \dots, x_{ik}$ plus some normally distributed error term:

$$y_i = \beta_0 + \beta_1 x_{i1} + \dots + \beta_k x_{ik} + \epsilon_i$$

where 

* $\beta_0$ is the intercept coefficient
* $\beta_1, \beta_2, \dots, \beta_k$ are the 'slope' coefficients for each input variable
* $\epsilon_i$ is the error term for observation $i$, assumed to be normally distributed with mean 0 and variance $\sigma^2$, that is $\epsilon_i \sim N(0, \sigma^2)$.

In the classical (frequentist) framework, our goal is to find the point estimates for the $\beta$ coefficients that minimize the sum of squared errors. We assume there is one true line that best fits the data, and we calculate standard errors to construct confidence intervals around that line.

In the Bayesian framework, we conceptualize the problem differently. We assume that each observation $y_i$ of the outcome variable comes from a normal distribution characterized by a mean $\mu_i$ and a standard deviation $\sigma$:

$$y_i \sim N(\mu_i, \sigma)$$

where the mean $\mu_i$ is still modeled as a linear combination of the input variable observations:

$$\mu_i = \beta_0 + \beta_1 x_{i1} + \dots + \beta_k x_{ik}$$

The crucial difference is that $\beta_0, \beta_1, \dots, \beta_k$ and $\sigma$ are not fixed values we are trying to hunt down. They are random variables with their own distributions. Our goal is to learn the **Posterior Distribution** of each these parameters given our data.  If we use $\beta$ to represent the vector of all regression coefficients, and noting that our data consists of the outcome variable vector $y$ and the matrix of input variables $X$, what we are looking for is the posterior distribution $P(\beta, \sigma \mid y, X)$.  In this context, Bayes' Theorem can be restated as:

$$
P(\beta, \sigma \mid y, X) \propto P(y \mid X, \beta, \sigma)P(\beta, \sigma)
$$

This means that the output of a Bayesian regression is not a single line or hyperplane that best fits the data, but a probability distribution of *all possible lines or hyperplanes* that are consistent with our data and our priors.  We are simulating posteriors for multiple parameters, and as you can imagine, this will need some computational horsepower.

Calculating the posterior distribution for complex models with multiple parameters is mathematically impossible to do using simple algebra. To solve this, we will need to employ Markov chain Monte Carlo (MCMC) simulation.  MCMC is a class of algorithms used to sample from complex probability distributions when direct sampling is difficult or impossible. It works by constructing a Markov chain (a sequence of random steps whose long-run behavior mimics the target distribution). Starting from an initial point, the algorithm proposes moves to new points in the parameter space and accepts or rejects them according to rules that ensure the chain will eventually sample in proportion to the desired distribution. Over many iterations, the collected samples approximate the underlying distribution, enabling estimation of quantities like means, variances, and credible intervals even in high-dimensional problems.

## Running a Bayesian linear regression model

We will use a random subset of the `ugtests` dataset from @sec-linear-reg-ols, which contains information about undergraduate students' scores over four years of their program. Our goal is to predict the `Final` year score based on the `Yr1`,`Yr2` and `Yr3` scores using Bayesian Linear Regression.  We will assume that this subset is all the data we have available for our model.


```{r}
# Load necessary packages
library(rstanarm)  
library(bayesplot)
library(ggplot2)  

# if needed, download ugtests data
url <- "http://peopleanalytics-regression-book.org/data/ugtests.csv"
ugtests <- read.csv(url)

# take a random sample of 100 rows
set.seed(42)
ugtests_bayes <- ugtests[sample(nrow(ugtests), 100), ]


```

### Specifying the Model

In `rstanarm`, we use `stan_glm()` with the `family = gaussian()` argument to fit a Bayesian linear regression model. The syntax is very similar to `lm()` and `glm()` for our previous chapters, but with a few extra arguments regarding the Bayesian specifics.

The `stan_glm()` function uses **weakly informative priors** by default. This is an excellent starting point for analysts. It essentially indicates that we do not have strong prior beliefs about the coefficients, but we want to avoid extreme values that are not plausible given the scale of our data.  It is also possible to set fully uninformative or 'flat' priors in models^[Setting prior arguments to `NULL` in modelling functions will achieve this.].  However this is highly discouraged because it can result in unusually extreme values influencing our simulations.  The default priors in `rstanarm` for a linear regression model are as follows:

*   **Slope Coefficients ($\beta$):** Normal distribution centered at 0 with a standard deviation of 2.5 times the standard deviation of the outcome variable divided by the standard deviation of the input variable. 
*   **Intercept ($\beta_0$):** Normal distribution centered at the mean of the outcome variable with a standard deviation of 10 times the standard deviation of the outcome variable.
*   **Residual Standard Deviation ($\sigma$):** An exponential distribution scaled to the standard deviation of the residuals of the outcome variable.  Exponential priors are commonly used for scale parameters to ensure positivity.

You can see that the the default weakly informative priors try to take into consideration the fact that the variables in the data may have different scales, as is the case in our `ugtests_bayes` data.  Let's first fit a multiple linear regression model, accepting the default priors. 

```{r}
# Fit a weakly informed Bayesian Linear Regression Model
set.seed(42)
weakinf_model <- stan_glm(
  formula = Final ~ Yr1 + Yr2 + Yr3,
  data = ugtests_bayes,
  family = gaussian(), # Indicates linear regression (gaussian/normal distribution)
  chains = 4,          # Number of independent MCMC chains 
  iter = 2000,         # Number of steps in each MCMC chain 
  diagnostic_file = file.path(tempdir(), "weakinf.csv"), # Save diagnostics to a temp file (optional)
  refresh = 0          # Suppress progress output (optional)
)
```

Let's review the various arguments we passed to `stan_glm()`:

*   `formula` & `data`: This is the same as we use in `lm()`.
*   `family = gaussian()`: Tells tells `stan` that we are doing standard linear regression (assuming errors are normally distributed).
*   `chains`: We run 4 independent MCMC simulations to ensure they all converge to the same answer.
*   `iter`: How many steps the simulation takes. The first 30-50% are usually discarded as "warm-up" iterations to learn the shape of the posterior, and the second half are kept for analysis.
*   `refresh`: Controls how often the MCMC simulation progress is printed to the console. Setting to 0 suppresses output.

### Interpreting the Results

Once the model is fit, we can examine the results. Unlike `lm()`, which gives us t-statistics and p-values, `stan_glm()` gives us summaries of the posterior distribution.

```{r}
# View summary of the model
summary(weakinf_model, digits = 3)
```

We can understand the basic summary output of estimates in a very similar way to OLS regression:

1.  The `mean` column provides the means of the posterior distributions for each parameter.  In this case: 
    *   `(Intercept)`: This is the posterior mean of the final year score assuming there was a score of zero in all of the previous years.
    *   `Yr1`: This is the posterior mean increase in Final year score associated with a one point increase in Year 1 score, assuming no change in the other input variables.
    *   `Yr2`: This is the posterior mean increase in Final year score associated with a one point increase in Year 2 score, assuming no change in the other input variables.
    *  `Yr3`: This is the posterior mean increase in Final year score associated with a one point increase in Year 3 score, assuming no change in the other input variables.
    * `sigma`: This is the posterior mean of the standard deviation of the residuals (the noise in the data not explained by the model).
    
2.  The `sd` column is the standard deviation of the posterior distributions. It represents the uncertainty of our estimates. 

3.  The `10%`, `50%` and `90%` columns provide median values and 80% credible intervals for the parameters. 

4.  The `mean_PPD` row provides the mean of the Posterior Predictive Distribution (PPD) for each parameter, as well as describing the uncertainty around the mean. This is the expected value of the outcome variable given the model and data.

5.  The `MCMC diagnostics` section provides information about the MCMC simulation.  In particular:
    *   `mcse`: The Monte Carlo Standard Error. This indicates the variability in the estimate due to the finite number of MCMC samples. This should be considered as a proportion of the standard deviation of the posterior.  Smaller values (< 5% of the standard deviation) are better.
    *   `Rhat`: The potential scale reduction factor. Values close to 1 indicate good convergence of the chains. Values significantly greater than 1 suggest that the chains have not converged well.
    *   `n_eff`: The effective sample size (ESS). This indicates how many independent samples the MCMC simulation effectively produced. Higher values are better, with at least 1000 considered sufficient.  This ensures that the are sufficient samples representing random variables that are independent and identically distributed (i.i.d.).


### Specifying informative priors

Although the default priors are generally fit for purpose in the `stan_glm()` function, there are times when we may have strong prior knowledge that may cause us to adjust our priors. Imagine you are informed by expert faculty that Year 1 scores are typically very weakly predictive of Final year scores or not at all predictive, while Year 2 and Year 3 scores are progressively more strongly predictive. You are also concerned that the priors in your initial model have resulted in an unreasonable likelihood of a negative intercept in the posterior, which does not make sense.  We can encode new beliefs into our model by specifying informative priors.

```{r}
# Define informative priors on the same model
set.seed(42)
inf_model <- stan_glm(
  formula = Final ~ Yr1 + Yr2 + Yr3,
  data = ugtests_bayes,
  family = gaussian(),
  prior = normal(location = c(0, 0.6, 0.8), scale = c(0.05, 0.1, 0.1), autoscale = TRUE),  # Prior for coefficients
  prior_intercept = normal(location = 50, scale = 20, autoscale = TRUE), # Prior for intercept
  prior_aux = exponential(rate = 1, autoscale = TRUE), # 'Auxiliary' Prior for sigma (residual std dev)
  chains = 4,
  iter = 2000,
  diagnostic_file = file.path(tempdir(), "inf.csv"),
  refresh = 0
)
```

In this example, we specified:

*   `prior`: A normal prior for the slope coefficients, centered around 0 for `Yr1`, 0.6 for `Yr2` and 0.8 for `Yr3`, with small `scale` standard deviations to reflect strong beliefs, especially for the `Yr1` coefficient based on our prior knowledge.  Setting `autoscale = TRUE` allows `stan_glm()` to adjust the priors based on the scale of the input variables.  This is highly recommended to avoid overly biasing the model. 
*   `prior_intercept`: A normal prior for the intercept, centered around 50 with a standard deviation of 20.  This is to reflect our belief that the intercept should show a very high likelihood of being positive.
*   `prior_aux`: We have specified is actually the default prior for `sigma` in `rstanarm` for informational purposes.

Let's view our informed model summary:

```{r}
# View summary of the informed prior model
summary(inf_model, digits = 3)

```

We now see that our posterior estimates have shifted based on our prior beliefs. The `Yr1` coefficient is now closer to zero, reflecting our belief that it has a weak effect on the Final year score, while the `Yr2` and `Yr3` coefficients have increased. The intercept distribution also appears more reasonable, given our prior knowledge.

## Examining posteriors

### Visualizing Posterior Parameter Distributions

Visualization is a particularly important communication tool in Bayesian statistics, because we are communicating uncertainty about our parameters. We can plot the distributions of plausible values for our informed model coefficients using the `mcmc_areas()` function from the `bayesplot` package.

::: {#fig-bayes-areas}
```{r}
# Plot posterior distributions for coefficients
mcmc_areas(
  inf_model, 
  pars = c("Yr1", "Yr2", "Yr3"),
  prob = 0.66, # 80% Credible Interval (shaded dark)
  prob_outer = 0.95 # 95% Credible Interval (limits)
) +
  theme_minimal()
```

Posterior distributions for the coefficients of our informed Bayesian linear regression model.
:::

In @fig-bayes-areas, the dark line at the peak of the density curve represents the most likely value for the coefficient. The width of the shaded area represents a 0.66 credible interval for the parameter, while the entire range plotted represents the 95% credible interval.

We can also look at the intervals explicitly using `mcmc_intervals`:

::: {#fig-bayes-intervals}
```{r}
mcmc_intervals(
  inf_model, 
  pars = c("Yr1", "Yr2", "Yr3"),
  prob = 0.66, 
  prob_outer = 0.95
) +
  theme_minimal()
```

66% (dark lines) and 95% (light lines) Credible intervals for the coefficients of our informed Bayesian linear regression model.
:::

Both of these visualizations are helpful in verifying our interpretations of the coefficients. For example, we can see that the 95% credible interval for the `Yr1` coefficient includes zero, suggesting that there is a reasonable probability that `Yr1` has little to no effect on `Final` scores, consistent with our prior beliefs.

### Posterior Predictive Distribution

Bayesian regression allows us to more precisely quantify our uncertainty when predicting outcomes for new data. In OLS regression, we typically get a single predicted value (point prediction) and perhaps a prediction interval. in Bayesian analysis, we generate a full Posterior Predictive Distribution (PPD). This distribution captures both our uncertainty about the model coefficients and the inherent variability in the data (the error term $\sigma$). 

For every simulated set of coefficients in our posterior, the model generates a prediction. This results in a distribution of predicted Final year scores.  Let's predict the Final year score for an improving student.

```{r}
# Define new data
new_student <- data.frame(Yr1 = 43, Yr2 = 111, Yr3 = 143)

# Generate posterior predictive distribution
post_pred <- posterior_predict(inf_model, newdata = new_student)

# Convert to data frame for plotting
pred_values <- data.frame(Final = as.vector(post_pred))
```

We can now plot exactly what we expect this student's Final year score to look like, including our uncertainty about the model parameters *and* the natural noise ($\sigma$) in the data.

::: {#fig-post-predict}
```{r}
library(ggdist)

# Plot the predictive distribution in a halfeye plot
ggplot(pred_values, aes(x = Final)) +
  stat_halfeye(
    .width = c(0.66, 0.95),
    fill = "lightblue",
    color = "blue"
  ) +
  labs(y = "Probability") +
  theme_minimal()
```

Distribution of predicted Final year score for a new student
:::

We can compute the 95% Prediction Interval directly from these samples:

```{r}
quantile(pred_values$Final, probs = c(0.025, 0.975)) |> 
  round()
```

This interval tells us that, given our model and data, there is a 95% probability that this specific student's Final score will fall within this range.

## Model Comparisons

Let's create a simple weakly informed Bayesian linear regression model using just `Yr2` as an input variable, so we can compare it to our full weakly informed and informed models.

```{r}
# Fit a simpler Bayesian Linear Regression Model
set.seed(42)
simple_model <- stan_glm(
  formula = Final ~ Yr2,
  data = ugtests_bayes,
  family = gaussian(),
  chains = 4,
  iter = 2000,
  diagnostic_file = file.path(tempdir(), "simple.csv"),
  refresh = 0
)
```

There are a number of ways we can compare the fit of Bayesian linear models. Some common ways involve computing R-squareds, determining predictive accuracy, or performing hypothesis tests on model fit.

### Bayesian $R^2$

We can calculate a Bayesian version of $R^2$. Unlike the single number in OLS regression, Bayesian $R^2$ is a distribution (because the coefficients are distributions). `rstanarm` provides a convenient function `bayes_R2()` to compute this.  Let's use it to compare the fit of our models.

```{r}
# Calculate Bayesian R-squared
r2_weakinf_full <- bayes_R2(weakinf_model)
r2_inf_full <- bayes_R2(inf_model)
r2_simple <- bayes_R2(simple_model)

# create data frame for visualization
r2_df <- data.frame(
  R2 = c(r2_weakinf_full, r2_inf_full, r2_simple),
  Model = rep(c("Weakly Informed Full", "Informed Full", "Simple"), each = length(r2_weakinf_full))
)

# plot posterior r-squared for all models
ggplot(r2_df, aes(x = R2, fill = Model)) +
  stat_halfeye(
    .width = c(0.66, 0.95),
    position = position_dodge(width = 0.5),
    alpha = 0.6
  ) +
  labs(y = "Probability") +
  theme_minimal()
```
We can see that our simple model has a very poor fit compared to both full models. The informed model has approximately the same median fit compared to the weakly informed model, but has more certainty about the fit.

### LOO Cross-Validation

We can use Leave-One-Out Cross-Validation (LOO-CV), which estimate out-of-sample predictive accuracy, to compare the predictive accuracy of models.       


```{r}
# Compare models using LOO
loo_simple <- loo(simple_model)
loo_informed_full <- loo(inf_model)
loo_weakinformed_full <- loo(weakinf_model)
loo_compare(loo_simple, loo_informed_full, loo_weakinformed_full)
```

The results will always rank the best performing model first, and shows the difference in expected log predictive density (ELPD) between the models.  A difference of more than 4 points is generally considered meaningful, but only if the standard error of the difference is small enough (less than half the ELPD difference itself).  In this case, we can see that our informed model is better in predictive performance than the weakly informed model, but not to a meaningful degree, while both full models are meaningfully better than the simple model.

### Hypothesis testing on model fit {#sec-bayes-model-hyp-test}

We can test the hypothesis that a model is a better fit than another using the Bayes Factor, which we covered in @sec-bayes-hyp-test.  We can use the `bayesfactor_models()` function from the `bayestestR` package to compute Bayes Factors for model hypothesis tests.  Let's test that our informed full model is a better fit than our weakly informed full model and our simple model.  Note that this will only work if a diagnostic file was written when your models were run.

```{r}
# Compute Bayes Factor for model comparison
library(bayestestR)
set.seed(42)
bayesfactor_models(inf_model, weakinf_model, simple_model)
```
We can see that the Bayes Factor strongly supports the informed full model over the other models.  However, Bayes Factor tests can be highly unreliable unless there has been extensive MCMC simulations performed during model fitting. It is recommended that at least 40,000 iterations are performed in model fitting to allow reliable Bayes Factor estimates.  Our models have not performed enough iterations to be confident about these Bayes Factor estimates. 

## Variable Standardization and Coefficient Hypothesis Testing

### Dealing with variable scale issues via standardization

Once we have fitted our model, it is good practice to check what priors were actually used and how they may have been rescaled to fit the data.  We can do this using the `prior_summary()` function in `rstanarm`.

```{r}
# remind ourselves of priors in our informed model
prior_summary(inf_model)
```

One thing we may see is that some of our priors have been substantially rescaled to account for the different scales of the input variables.  This is because `rstanarm` automatically standardizes input variables before fitting the model, and then rescales the priors accordingly.  This is generally a good thing, as it helps the MCMC simulation converge more easily.  However, it is important to be aware of this rescaling when interpreting the priors.  Moreover, if our variables have different scales, problems can arise when we do hypothesis testing of coefficients using Bayesian inference.

Recall that in our data, the `Yr1` scale is 0-100, the `Yr2` and `Yr3` scales are 0-200 and the `Final` scale is 0-300.   Explicitly standardizing these scales before modeling can have benefits in defining our priors and in running hypothesis tests.  We can standardize the scales of our variables using the `scale()` function in R.  This function takes the mean of each variable and sets it to zero, and expresses each value as a positive or negative multiple of the standard deviation from the mean.

```{r}
#  Standardize all variables
library(dplyr)

ugtests_bayes_std <- ugtests_bayes |> 
  mutate(across(everything(), scale))
```

Now we can rerun our informed model on the scaled data:

```{r}
# Fit the Bayesian Linear Regression Model on standardized data
set.seed(42)
inf_model_std <- stan_glm(
  formula = Final ~ Yr1 + Yr2 + Yr3,
  data = ugtests_bayes_std,
  family = gaussian(),
  prior = normal(location = c(0, 0.6, 0.8), scale = c(0.05, 0.1, 0.1), autoscale = FALSE),  # Prior for coefficients
  prior_intercept = normal(location = 0, scale = 1, autoscale = FALSE), # Prior for intercept
  prior_aux = exponential(rate = 1), # Prior for sigma (residual std dev)
  chains = 4,
  iter = 2000,
  diagnostic_file = file.path(tempdir(), "inf_std.csv"),
  refresh = 0
)

summary(inf_model_std, digits = 3)
```

We can now check the priors used in this standardized model and we see that there is no rescaling:

```{r}
prior_summary(inf_model_std)
```

Working with the standardized model has several advantages.  First, the coefficients are now directly comparable to each other, since they are all expressed in terms of standard deviations.  Previously, the effect of a one unit increase in `Yr1` was not comparable to that of a one unit increase in `Yr2`, since they were on different scales.  Now, the effect of a one standard deviation increase in `Yr1` is directly comparable to that of a one standard deviation increase in `Yr2`.  This makes it easier to interpret the relative importance of each input variable.  Second, the priors are now directly interpretable in terms of standard deviations.  

### Hypothesis testing on coefficients using ROPE

We can also now do hypothesis testing on the coefficients more easily.  We can more safely use the `describe_posterior()` function from the `bayestestR` package to get a description of the posterior distributions.

```{r}
library(bayestestR)
describe_posterior(inf_model_std)
```
The ROPE (Region of Practical Equivalence) is typically determined to be between -0.1 and 0.1 standard deviations of the output variable (@kruschke).  If the input variables are on a different scale to the output variable (as they are in our earlier modeling), the ROPE may not make sense.  Because we have standardized the variables, we can be more confident that the ROPE is meaningful.  This summary suggests that `Yr2` and `Yr3` are extremely likely to be positive predictors of `Final`, while `Yr1` is not.  A more terse summary can be obtained by using the `equivalence_test()` function, which will explicitly reject coefficients that are practically different from zero:

```{r}
# test for equivalence of coefficients to zero
equivalence_test(inf_model_std)
```
### Hypothesis testing on coefficients using Bayes Factor

We can also use Bayes Factors to test whether our coefficients are more or less likely to be practically zero after fitting our data.  The `bayesfactor_parameters()` function from the `bayestestR` package can compute Bayes Factors for each coefficient. We will use our recommended ROPE of -0.1 to 0.1 standard deviations.

```{r}
# Compute Bayes Factor against a null of practical equivalence to zero
set.seed(42)
bayesfactor_parameters(inf_model_std, null = c(-0.1, 0.1))
```

We see that all three coefficients are more likely to be practically different from zero after fitting our data.  However, as in @sec-bayes-model-hyp-test,
this result will be unreliable as we have not performed sufficient MCMC iterations to allow for reliable Bayes Factor testing.

### Testing specific hypotheses about coefficients

We may want to test specific hypotheses about our coefficients, and Bayesian inference gives us a great deal of flexibility to do this.  For example, we may want to know the probability that the `Yr3` coefficient is more than double than the `Yr2` coefficient.  We can do this by extracting the posterior samples and calculating the proportion of samples where this condition holds.

```{r}
# Extract posterior samples
posterior_samples <- as.data.frame(inf_model_std)

# Calculate the probability that Yr3 > Yr2
prob_Yr3_greater_Yr2 <- mean(posterior_samples$Yr3 > 2*posterior_samples$Yr2)
round(prob_Yr3_greater_Yr2, 2)
```

This allows us to say that there is a `r `round(prob_Yr3_greater_Yr2*100)`% probability that the effect of `Yr3` is more than double that of `Yr2`, given our priors and data.


## Model Diagnostics and Validation

Because Bayesian models rely on MCMC simulation, we must verify that the simulation worked correctly. If our MCMC chains did not behave as expected, our results will probably be invalid. There are several diagnostics we can use to assess the quality of our MCMC simulation.

### Trace Plots

Trace plots show the path of the MCMC sampling chains. We want to see "fuzzy caterpillars"-â€”-chains that mix well and oscillate around a stable mean. We do not want to see trends (going up or down) or chains that stay separate from each other.  We can use the `mcmc_trace()` function from the `bayesplot` package to visualize the trace plots for our model coefficients.

::: {#fig-trace-plot}
```{r}
# Plot trace plots for coefficients
mcmc_trace(inf_model, pars = c("Yr1", "Yr2", "Yr3")) +
  theme_minimal()
```

Trace plots of the MCMC simulation. The four colors represent the four independent chains. The fact that they look like random noise and overlap perfectly, giving a "hairy caterpillar" appearance, indicates good convergence.
:::

### Posterior Predictive Checks

Another critical check is to see if the model can generate data that looks like our observed data. This is called a **Posterior Predictive Check (PPC)**. If our model is good, data simulated from the model should resemble the `Final` histogram of our actual dataset.

We use `pp_check()`, which is available in both the `rstanarm` and in `bayesplot` packages for this.

::: {#fig-pp-check}
```{r}
# Posterior predictive check
pp_check(inf_model) +
  theme_minimal()
```

Posterior Predictive Check. The dark line (`y`) is the distribution of our actual Final year data. The light blue lines (`yrep`) are Final year datasets simulated by our model.
:::

In @fig-pp-check, we see that the simulated datasets (light blue) overlay the actual data (dark blue) to within a reasonable range. This suggests our model structure (Linear Regression) fits the data generating process well. If, for instance, the real data had two humps (bimodal) and our simulations only had one, this would raise a concern that the model is misspecified.


### Sensitivity to priors and other considerations 

It is good practice to check how sensitive your results are to the choice of priors. You can do this by fitting the model with different priors (e.g., weakly informative vs. informative) and comparing the posterior distributions of the coefficients. If the posteriors change significantly with different priors, it suggests that your data may not be strong enough to overcome the influence of the priors.  If this is the case, it would be important to acknowledge this in your analysis and consider collecting more data if possible.  

On the other hand, large samples can result in priors being 'swamped' or 'overwhelmed' by the data, leading to similar posterior distributions regardless of the priors used.  This is not necessarily a problem, but it is important to be aware of this phenomenon when interpreting your results.  In cases where priors are swamped, one of the values of Bayesian inference is negated (namely the ability to incorporate prior knowledge).  However, the other advantages of Bayesian inference (such as the rich probabilistic interpretation of coefficients and predictions) still hold.  It is the choice of the analyst to decide whether Bayesian inference is appropriate in such cases.

Many of the other model diagnostics we used in OLS regression (e.g., residual plots, tests for homoscedasticity, etc.) are still applicable in Bayesian regression.  The mean of the Posterior Predictive Distribution can be used to compute residuals, and these can be analyzed in the same way as in OLS regression to check residuals and homoscedasticity.  As with classical models, the `fitted()` function can be used to extract the mean fitted values from the model.

## Learning exercises

### Discussion questions

1.  What are "weakly informative priors"? Why might an analyst prefer these over "flat" (uninformative) priors or informative priors?

2.  Briefly explain the purpose of Markov chain Monte Carlo (MCMC) simulation in Bayesian regression.

3.  How does the interpretation of a regression coefficient ($\beta$) differ between the classical regression framework and the Bayesian framework?

4.  What is a posterior predictive distribution (PPD), and how does it differ from a fitted point prediction in OLS regression?

5.  What information does the `Rhat` statistic provide about MCMC convergence? What values of `Rhat` indicate good convergence?

6.  What are three ways to compare Bayesian regression models? Briefly describe each.

7.  Explain how to interpret the results of a comparison between two models using Leave One Out Cross-Validation (LOO-CV).

8.  In a Bayes Factor hypothesis test of regression models or model coefficients, what primarily determines how reliable the Bayes Factor estimate is?

9.  Why is variable standarization helpful when defining informative priors or using a Region of Practical Equivalence (ROPE) for hypothesis testing?

10.  Describe what a "Trace Plot" and a "Posterior Predictive Check" (PPC) show, and what patterns (or lack thereof) indicate a healthy and well-specified model.

### Data exercises

Use the `sociological_data` set from the exercises in @sec-lin-reg-ols-exercises. Ensure that categorical variables are coerced to factors and missing data is removed.  Reduce the size of the dataset by taking a random sample of 100 rows.  Ensure you set a seed to ensure you can replicate your work.  

1.  Load the `rstanarm`, `bayesplot`, and `ggplot2` packages.

2.  Fit a Bayesian linear regression model predicting `annual_income_ppp` using all other variables in the dataset. Use `stan_glm` with `chains = 4`, `iter = 2000`, and the default weakly informative priors.

3.  Run a summary of the model. Examine the `Rhat` and `n_eff` columns. Did the chains converge successfully?

4.  Generate Trace Plots for the coefficients of `education_months` and `family_size`. Do they resemble "fuzzy caterpillars"?

5.  Check the priors that were actually used by the model using `prior_summary()`. How did `rstanarm` adjust the scales of the priors relative to your data?

6.  Visualize the posterior distributions of the coefficients using `mcmc_areas()`. Which variables appear to have the strongest positive and negative effects on `annual_income_ppp`?

7.  Interpret the posterior mean and the 95% credible interval for the `education_months` coefficient. Can you state with 95% probability that education has a positive effect on income?

8.  Imagine you possess expert knowledge from a previous study suggesting that `family_size` usually has a slightly negative effect on income, and `work_distance` generally has no effect.  Construct and examine a new model using informative priors as follows:
    *   Set a normal prior for `family_size` with a location (mean) of -0.2 and a tight scale.
    *   Set a normal prior for `work_distance` with a location of 0 and a tight scale.
    *   Maintain the other priors by setting their location to 0 and their scale to 2.5.
    *   Consider how to set the priors appropriately for the categorical variables (Hint: look at the coefficient summary from your weakly informed model).

9.  Compare your "Weakly Informed" model (from step 3) and your "Informed" model (from step 8) using `bayes_R2()`. Visualise the two distributions of $R^2$. Does the incorporation of prior beliefs significantly change the explained variance?

10. Use Leave-One-Out Cross-Validation (`loo()`) to compare the predictive performance of the two models. Which model is preferred?

11. Using your preferred model, perform a Posterior Predictive Check (`pp_check`). Does the simulated data resemble the observed distribution of `annual_income_ppp`?

12. Rerun your informed model on scaled version of your data.  Determine which coefficients are practically different from zero based on the ROPE.  

13. Calculate the specific probability that the coefficient for `education_months` is larger than the coefficient for `languages`.

14. Create a hypothetical individual profile (a new dataframe) representing a skilled worker with high education and a large family.

15. Generate the Posterior Predictive Distribution for this individual's income. Plot the distribution.

16. Report the 90% Prediction Interval for this individual. Explain, in plain language, what this interval represents regarding the uncertainty of your prediction.
